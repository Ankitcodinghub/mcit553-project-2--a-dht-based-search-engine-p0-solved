# mcit553-project-2--a-dht-based-search-engine-p0-solved
**TO GET THIS SOLUTION VISIT:** [MCIT553 Project 2 -A DHT-based Search Engine P0 Solved](https://www.ankitcodinghub.com/product/mcit553-mcit-online-553-project-2-a-dht-based-search-engine-p0-solved/)


---

üì© **If you need this solution or have special requests:** **Email:** ankitcoding@gmail.com  
üì± **WhatsApp:** +1 419 877 7882  
üìÑ **Get a quote instantly using this form:** [Ask Homework Questions](https://www.ankitcodinghub.com/services/ask-homework-questions/)

*We deliver fast, professional, and affordable academic help.*

---

<h2>Description</h2>



<div class="kk-star-ratings kksr-auto kksr-align-center kksr-valign-top" data-payload="{&quot;align&quot;:&quot;center&quot;,&quot;id&quot;:&quot;124622&quot;,&quot;slug&quot;:&quot;default&quot;,&quot;valign&quot;:&quot;top&quot;,&quot;ignore&quot;:&quot;&quot;,&quot;reference&quot;:&quot;auto&quot;,&quot;class&quot;:&quot;&quot;,&quot;count&quot;:&quot;4&quot;,&quot;legendonly&quot;:&quot;&quot;,&quot;readonly&quot;:&quot;&quot;,&quot;score&quot;:&quot;5&quot;,&quot;starsonly&quot;:&quot;&quot;,&quot;best&quot;:&quot;5&quot;,&quot;gap&quot;:&quot;4&quot;,&quot;greet&quot;:&quot;Rate this product&quot;,&quot;legend&quot;:&quot;5\/5 - (4 votes)&quot;,&quot;size&quot;:&quot;24&quot;,&quot;title&quot;:&quot;MCIT553  Project 2 -A DHT-based Search Engine P0 Solved&quot;,&quot;width&quot;:&quot;138&quot;,&quot;_legend&quot;:&quot;{score}\/{best} - ({count} {votes})&quot;,&quot;font_factor&quot;:&quot;1.25&quot;}">

<div class="kksr-stars">

<div class="kksr-stars-inactive">
            <div class="kksr-star" data-star="1" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="2" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="3" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="4" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="5" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>

<div class="kksr-stars-active" style="width: 138px;">
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>
</div>


<div class="kksr-legend" style="font-size: 19.2px;">
            5/5 - (4 votes)    </div>
    </div>
Assignment Project Exam Help

1 Overview

routing protocol. The use of OLSR can be turned on using a command line flag ‚Äìrouting=NS3 to simulator-main.cc . You are then responsible for first developing Chord as an overlay network layered on top of your routing protocol, followed by building the search engine application that uses Chord.

To help you get started, files related to project 2 include:

‚Ä¢ simulator-main.cc: In addition to what you learnt in project 1, it has SEARCH LOG() and

CHORD LOG() functions to log all messages relevant to the search engine and Chord overlay, respectively. It also includes modules for CHORD and PENNSEARCH.

‚Ä¢ scenarios/pennsearch.sce: An example scenario file that contains a simple 3 node Chord network, the publishing of document keywords by two nodes, and three example queries.

‚Ä¢ keys/metadata0.keys, keys/metadata1.keys: These keys are located inside the contrib/upenncis553/ directory and not in the scenario directory. Each file contains the meta-data for a set of documents, where each row ‚ÄúDOC T1 T2 T3‚Ä¶‚Äù is a set of keywords (in this case, T1, T2, and T3) that can be used to search for a document with identifier DOC. Each document identifier can be a web URL or a library catalog number, and for the purpose of this project, they are simply a string of bytes that uniquely represent each document. In practice, these keywords are generated by reading/parsing web content or other documents to extract keywords. However, since parsing web pages is not the focus of this project, we have skipped this step, and supply these document keywords to you.

‚Ä¢ penn-chord-*.[h/cc]: Skeleton code for your Chord implementation.

‚Ä¢ penn-search-*.[h/cc]: Skeleton code for your PennSearch implementation.

The command to compile and run project 2 is the same as Section 2.3 and 2.4 in project 1 code documentation. Please do not use -result-check flag in the command and please comment out calls to checkNeigbhorTableEntry() and checkRoutingTableEntry() if you use your LS and DV implementation. You can also opt to use ns-3‚Äôs OLSR implementation instead of your own LS and DV.

Note that our skeleton code is a starting point, and you are allowed to be creative and structure your code based on your own design. For regular credits, you are however not allowed to make any code changes outside of upenn-cis553 directory, nor are you allowed to change simulator-main.cc. In addition to our sample test script, we expect you to design additional test cases that demonstrate the correctness of your PennSearch implementation. We encourage you to get started early. As a result, we have included a milestone 1 where you should have a basic Chord implementation.

2 PennChord

Chord nodes will execute as an overlay network on top of your existing routing protocol, i.e., all messages between any two Chord nodes 1 and 2 will traverse the shortest path computed by the underlying routing protocol. The PennChord overlay network should be started only after the routing protocol has converged (i.e. finish computing all the routing tables). You can assume that the links used in the underlying routing protocol computation does not changed while PennChord is executed. Also, not all nodesAssignment Project Exam Help

Correct Chord Behavior

to implement the actual stabilization functionality described in the Chord paper. In particular, we will check for the following features:

‚Ä¢ Consistent routing. All nodes agree on lookup(k).

‚Ä¢ Well-formed ring. For each node n, it‚Äôs successor‚Äôs predecessor is itself. One easy way is to make use of your RINGSTATE command described below to ensure that the Chord ring is formed correctly.

‚Ä¢ Correct storage. Every item K is stored at the correct node (i.e. lookup(k))

‚Ä¢ Performance. For a given network size, you need to compute and output the average hop count required by Chord lookups that occur during the duration of your simulation. In other words, you should implement the code that will capture the number of hops required by each lookup and output using CHORD LOG the average hop count across all lookups when the simulation ends. The average hop count must exclude lookups that are generated during periodic finger fixing. After finger fixing is correctly implemented, the average hop count should be log(N) instead of N, where N is the number of nodes in the Chord overlay network.

‚Ä¢ Stabilization protocol. Enough debugging messages (not too many!) to show us that periodic stabilization is happening correctly. Since stabilization generates large numbers of messages, you should provide mechanisms to turn on/off such debugging in your code.

Summary of Commands

‚Ä¢ Start landmark node: Designate a node as your landmark (i.e. node 0). E.g. ‚Äú0 PENNSEARCH CHORD JOIN 0‚Äù will designate node 0 as the landmark node, since the source and landmark nodes are the same.

‚Ä¢ Nodes join: A PennChord node joins the overlay via the initial landmark node. E.g. ‚Äú1 PENNSEARCH CHORD JOIN 0‚Äù will allow node 1 to join via the landmark node 0. Once a node has joined the network, items stored at the successor must be redistributed to the new node according to the Chord protocol. For simplicity, you can assume all joins and leaves are sequential, i.e. space all your join events far apart such that the successors and predecessors are updated before the next join occurs.

‚Ä¢ Voluntary node departure: A PennChord node leave the Chord network by informing its successor and predecessor of its departure. E.g. ‚Äú1 PENNSEARCH CHORD LEAVE‚Äù that will result in node 1 leaving the PennChord network. All data items stored should be redistributed to neighboring nodes accordingly. For simplicity, you can assume all joins and leaves are sequential.

‚Ä¢ Ring state debug:Assignment Project Exam HelpAt any node X, a ‚ÄúX PENNSEARCH CHORD RINGSTATE‚Äù command will

initiate a ring output message that initiates from node X, and traverse the entire Chord ring in a clockwise direction to output all successors and predecessors. This message will terminate at the initiating node X. Each node curretNodeAddr that receives the message will generate the following output in a single line usinghttps://poPRINTwcoLOGder.com:

Ring State

Pred&lt;predNode #, predIPAddress, predHash&gt;

Succ&lt;succNode #, succIPAddress, succHash&gt;

Debug Logs (for Grading)

For grading purposes, in addition to ring state output above, we require the following information to be printed using CHORD LOG . These debugging messages can be turned off using command ‚Äù* PENNSEARCH VERBOSE CHORD OFF‚Äù. All Chord identifiers should be printed in hexadecimal.

‚Ä¢ Lookup issue debug: Every time a node issues a lookup request, the following message is printed:

‚Ä¢ Lookup forwarding debug: Every time a node forwards a lookup request, the following message is printed:

‚Ä¢ Lookup results debug: Every time a node returns a result in response to a lookup request back to the node that originated the initial lookup request, the following message is printed:

CHORD LOG

Note that there are no specific commands that will generate lookups. They are generated either by Chord‚Äôs periodic finger fixing, or PennSearch‚Äôs invocation of PUBLISH and SEARCH (see below). For our testing purposes, you must leave out lookups generated by finger fixing in theoutput, but only print out lookups that are initiated by PennSearch.

Cryptographic Hashes

Note that the 160-bit Chord cryptographic hashes can be generated using SHA1, which is available using the OpenSSL Crypto development library. In order to do that, you need to include the libcypto library during compilation. Specifically, take the following steps:

1. Install OpenSSL in your VM:

2. Run ‚Äù./waf configure‚Äù to update your configure if this is your first time to run this program. It can also check if you have installed OpenSSL correctly; otherwise the configuration would fail.Assignment Project Exam Help

3. To use libcrypto, you need to:

SHA1(message, length, digest);

For the purpose of this project, you can use the first 32 bits (m = 32) of the SHA1 value as the Chord ID and will receive full credit if your functionality is working correctly. If you can use the entire 160 bits as Chord ID, you will receive extra credit.

3 PennSearch

To test your Chord implementation, we will require you to write PennSearch, which is a simple keyword based search engine.

Basics of Information Retrieval

We first provide some basic knowledge that you would need to understand keyword-based information retrieval. We consider the following three sets of document keywords, one for each of Doc1, Doc2, and Doc3:

Doc1 is searchable by keywords T1 or T2. Doc2 is searchable by T1, T2, T3, and T4, and Doc3 is searchable by T3, T4, and T5. Typically, these searchable keywords are extracted from the actual documents with identifiers Doc1, Doc2, and Doc3.

Based on these keywords, the inverted lists are {Doc1, Doc2} for T1, {Doc1, Doc2, Doc3} for T2, {Doc2, Doc3} for T3, {Doc2, Doc3} for T4, and {Doc3} for T5. Each inverted list for a given keyword essentially stores the set of documents that can be searched using the keyword. In a DHT-based search engine, for each inverted list Tn, we store each list at the node whose Chord node is responsible for the key range that includes hash(Tn).

A query for keywords ‚ÄúT1 AND T2‚Äù will return the document identifiers ‚ÄúDoc1‚Äù and ‚ÄúDoc 2‚Äù, and the results are obtained by intersecting the sets {Doc1, Doc2}, and {Doc1, Doc2, Doc3}, which are the inverted lists of T1 and T2 respectively. We only deal with AND queries in PennSearch, so you can ignore queries such as ‚ÄúT1 OR T2‚Äù.

Note that the query result is not the actual content of the documents, but rather the document identifiers that represent documents that include both T1 and T2. In typical search engine, an extra document retrieval phase occurs at this point to fetch the actual documents. We consider the actual document content retrieval step out of scope of this project.

Summary of Commands

‚Ä¢ Inverted list publishing: ‚Äú2 PENNSEARCH PUBLISH metadata0.keys‚Äù means that node 2 reads the document metadata file named metadata0.keys. Node 2 then reads each line, which is of the form ‚ÄúDoc0 T1 T2 T3 ‚Ä¶‚Äù, which means that the Doc0 is searchable by T1, T2, or T3. AfterAssignment Project Exam Help

‚Ä¢ Search query: ‚Äú1 PENNSEARCH SEARCH 4 T1 T2‚Äù will initiate the search query from node 1, and take the following steps via node 4:

(a) Node 1 contacts node 4 with query ‚ÄùT1 AND T2‚Äù;

(b) Node 4 issues a Chord lookup to find the node that stores the inverted list of T1, i.e., the nodethat T1 is hashed to (e.g., Node T1), and sends the query ‚ÄùT1 AND T2‚Äù to Node T1;

(c) Node T1 retrieves inverted list for T1 from its local store, issues a Chord lookup to find the node that T2 is hashed to (e.g., Node T2), and sends the retrieved inverted list for T1 together with query ‚ÄùT2‚Äù to Node T2;

(d) Node T2 send the intersection of the inverted lists of T1 and T2 as the final results back either directly back to node 1, or to node 4 (which forwards the results to node 1). If there are no matching documents, a ‚Äúno result‚Äù is returned to node 1.

NOTES

Debug Logs (for Grading)

SEARCH LOG

For grading purposes, we require the following information to be printed using:

‚Ä¢ Inverted list publish debug: Whenever a node publishes a new inverted list entry, the following debug message is generated:

‚Ä¢ Inverted list storage debug:Assignment Project Exam HelpWhenever a node (that the keyword is hashed to) receives a new inverted list entry to be stored, the following debug message is generated:

Store&lt;keyword, docID&gt;

‚Ä¢ Search debug: Whenever a node issues a search query with terms T1, T2,‚Ä¶,Tn, you should output:

‚Ä¢ Inverted list shipping debug: For each inverted list &lt;docIDList&gt; being shipped in the process of the search, you should output:

‚Ä¢ Search results debug: At the end of intersecting all keywords (T1, T2, ‚Ä¶, Tn), output the final document list &lt;docIDList&gt; that is being sent back to the initial query node:

‚Ä¢ Empty search results debug: In the process of the search, if any intermediate node results in an empty inverted list to be sent back to the initial query node, you should output:

4 Milestones

‚Ä¢ Milestone 1: (15%)

PRINT LOG

We expect a basic Chord implementation where the ring stabilization protocol works correctly. At this stage, finger table implementation is optional for this milestone. We require only the ringstateoutput to make sure your ring is formed correctly and maintained as nodes enter/leave the Chord overlay. For this milestone, upload a video recording of your functioning basic Chord to Gradescope.

‚Ä¢ Final (85%)

Complete working implementation of PennChord and PennSearch.

Assignment Project Exam Help

Extra credits

‚Ä¢ Handling big numbers (5%): If you use the entire 160 bits from SHA1 as the Chord ID, you will get 5% extra credit. This will require you to design a mechanism to store, add, mod, compare, and display big integers that cannot fit in primitive data types.

‚Ä¢ Bandwidth efficient search engine (10%): The basic PennSearch can be enhanced to save bandwidth as follows: perform the intersection of keywords starting from the one with smallest inverted list, and use of bloom filters. Implement these features and show that your implementation results in lower bandwidth utilization compared to the regular implementation.

‚Ä¢ Enhanced search features (5% for each bullet point): Enhanced your search engine with at least the following features:

‚Äì Generating the document keywords (e.g. metadata0.keys, metadata1.keys) with actual web pages (&gt;20) that you have downloaded, and replacement docID with actual URLs. After returning the search results, fetch the actual documents themselves. Do the last step sparingly so as not to overload existing web servers with your http requests.

‚Äì Rank search results based on a reasonable search metric, such as TF-IDF.

‚Äì Support inverted lists that are larger than MTU size of 1500 bytes. For instance, you can use a fragmentation/defragmentation scheme that breaks up an inverted list into smaller size lists in executing the search query.

‚Ä¢ Chord file system (20%). The Chord File System (CFS) is a fairly sophisticated application that uses Chord. Hence, this has more extra credit than other applications. You need to demonstrate to us that you can take a few fairly large files, store it in CFS, and retrieve them correctly. To earn the entire 20%, you need to implement all the functionalities described in the CFS paper. You can search online for the MIT CFS paper.

‚Ä¢ Churn handling and failure detection (20%): Add support to emulate failures of PennChord nodes, mechanisms to detect failures of PennChord nodes, and repair the routing state in PennChord accordingly when failures occur. To ensure robustness, each node needs to maintain multiple successors. All churn events (node joins, leaves, or failures) can happen concurrently, and a node that fails can rejoins the overlay later. You can however not concern yourself with failures at

the network layer, i.e .all failures occur at the application-layer node.Assignment Project Exam Help

‚Ä¢ PennSearch on mobile devices (20%). Using your Android phones, demonstrate a small (2-3) PennSearch network running on mobile devices. This requires taking the ns-3 code and compiling it on Android. If you do not have an Android, you can use an Android emulator.
